# js-basics
js 基础知识总结


# i++和++i 的区别：
// i++: 先拿i的值进行计算，运算完成 本身加一
// ++i：先自身加一，再去运算
// 例如：
  var a =5;
  console.log(2+(a++)+(++a)+(++a)+(i++)) //30
  // 2+5= 7 a = 6
  // 7+7 = 14 a = 7
  // 14+8 = 22 a = 8
  // 22+8 = 30 a = 9

 #预解释 
 function fn(){
      var i =10;
      return function(n){
        console.log(n + (++i))
      }
    }
    var f = fn();
    f(10) //10+ 11
    f(20) // 20 +12
    fn()(10) //21
    fn()(20) // 31

  首先 在window下预解释：
    1.变量提前  var i, fn= xxxfff000 开辟空间, 存放函数字符串
    2.代码开始执行：
      f = fn执行完成返回结果赋给f ,fn()执行也就是 xxxfff000()执行形成私有作用域（暂定为A）；
      私有作用域A开始预解释：
        1.有形参先给形参赋值，上面没 var i；
        2.代码开始执行：
          i=10 ；
          return 一个函数，相当于新开一个内存空间（xxxfff111）存放函数体内容；
    =======================================================================================      
      f(10) 调用执行 -相当于 xxxfff111(10)  ->函数执行又形成私有作用域；
        1.形参赋值 n =10 
        2.代码执行：
          10+（++i）->当前作用域没变量 i ,找上级作用域A， ++i 使A中的i 变为11
          10+11 =21；
          代码执行完毕，当代作用域没被引用，随之销毁
      f(20) 调用执行 ->相当于 xxxfff111(20)  ->函数执行又形成私有作用域；
        1.形参赋值 n =20 
        2.代码执行：
          20+（++i）->当前作用域没变量 i ,找上级作用域A， ++i 使A中的i 变为12
          20+12 =32；
          代码执行完毕，当代作用域没被引用，随之销毁

      window不关闭 变量f 不销毁      
    ===========================================================================================
    fn()(10) 调用执行：
      形成新的私有作用域B：
      1.变量提升 var i,
      2.代码执行：
        i= 10
        return 一个函数，相当于开辟新的内存空间（xxxfff222）(10)
          1.形参赋值 n =10;
          2.代码执行：
            10+（++i）->当前作用域没变量 i ,找上级作用域A， ++i 使B中的i 变为11
            10+11 = 21
            代码执行完毕，当代作用域没被引用，随之销毁 ,作用域B没被引用也随之销毁
    ===========================================================================================
     fn()(20) 调用执行：
      形成新的私有作用域C：
      1.变量提升 var i,
      2.代码执行：
        i= 10
        return 一个函数，相当于开辟新的内存空间（xxxfff333）(20)
          1.形参赋值 n =20;
          2.代码执行：
            20+（++i）->当前作用域没变量 i ,找上级作用域A， ++i 使B中的i 变为11
            20+11 = 31
            代码执行完毕，当代作用域没被引用，随之销毁 ,作用域C没被引用也随之销毁        

    ==========================================================================================
    函数每次执行都会形成私有作用域

# this
  this 是谁 和函数在哪定义在哪执行的都没有关系；
  js中的this 代表的是当前行为执行的主体 me.eat() this->me
  如何区分this：
    1. 函数执行，首先看函数名前是否有 . ,有的话， .前面是谁，this就是谁，没有，this就是window
    2. 自执行函数里面的this 永远是window
    3. 给元素的某一个事件绑定方法，该方法触发的时候，this就是元素
  
# 单例模式  