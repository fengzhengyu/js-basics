<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <style>
    *{
      margin: 0;
      padding: 0;
    }
    #box{
      margin: 100px;
      width: 200px;
      height: 200px;
      border: 20px solid green;
      padding: 10px;
      overflow: hidden;
    }
  
  </style>
</head>
<body>
  <div id="box" class="test" name="风筝" index="0">
      js 盒子模型： 通过js提供的一系列的属性和方法， 获取页面元素的信息
      js 盒子模型： 通过js提供的一系列的属性和方法， 获取页面元素的信息 
      js 盒子模型： 通过js提供的一系列的属性和方法， 获取页面元素的信息
      js 盒子模型： 通过js提供的一系列的属性和方法， 获取页面元素的信息
      js 盒子模型： 通过js提供的一系列的属性和方法， 获取页面元素的信息 
      js 盒子模型： 通过js提供的一系列的属性和方法， 获取页面元素的信息
      <p></p>
  </div>

  <script>
    // js 盒子模型： 通过js提供的一系列的属性和方法， 获取页面元素的信息
    var oDiv = document.getElementById('box')
    console.dir(oDiv)
    oDiv.attributes.getNamedItem('name')
    oDiv.classList.add('text100')
    
    //内容的宽高: 没有设置height 容器的高度会根据里面内容进行适应。这样获取的就是真实的高度 


    // client系列
    // clientHeight/clientWidth ：内容的高度或宽度加上下padding /padding ->220
    // clientTop/clientLeft: 就是border 的widht ->20


    oDiv.contentEditable = true; //可编辑文本 默认false

    // offset系列
    // offsetHeight/offsetWidth :  ClientHeight +上下变宽 / ClientWidth + 左右边框  220+40=260;
    // offsetTop/offsetLeft:  当前元素的外边框距离父级参照物的内边框的偏移量
    // offsetParent： 当前元素的父级参照物

    // scroll系列
    // scrollHeight / scrollWidth:  与clientHeight/clientWidth 一模一样（前提是： 容器中的内容没有溢出的情况下）
    //                              如有容器中内容有溢出： 真实内容高包(含移除的) + 上下padding
    //   他们与设置 “overflow: hidden; ” 对最终的结果是有影响的 ，在不同的浏览器得到的值不同，所以获取的值是 “约等于”的值 
    // scrollTop/scrollLeft : 滚动条卷去的高度  / 宽度

    // 总结关于js盒子模型取值的问题：
    //  1. 取值始终是整数 会自动四舍五入
    //  2. clientHeight/clientWidth就是当前浏览器的可视窗口的宽高 也就是一屏的高度
    //  3. scrollHeight / scrollWidth 就是当前页面的真实的高度、宽度，也就是所有屏加起来，是一个约等于值
    //  4. 不管什么浏览器，不管设置还是获取，想要兼容： document.documentElement[attr] || document.body[attr] ->必须 document.documentElement[attr]在前

    // 封装
      function win(attr,value) {
        if(typeof value === 'undefined'){ //没有传值就是获取属性
          
          return document.documentElement[attr] || document.body[attr]
        }else{
           document.documentElement[attr] = value 
           document.body[attr] = value;
        }
      }
  </script>
</body>
</html>