<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>构造函数模式基础</title>
</head>
<body>
  <script>
    /* 
      构造函数的目的就是为了创建一个自定义类，并且创建这类的实例

      构造函数与工厂模式的区别：
        1、执行的时候：
          工厂模式是普通函数执行
          构造函数是 new 函数名，通过new 就是一个类，执行的返回值就是一个实例
        2、函数执行的时候：
          相同点： 都是形成私有作用域，然后形参赋值，预解释，代码从上到下执行
          不同点： 构造函数 不用手动写，浏览器会自己默认创建一个对象数据类型值（这个对象就是当前类的实例）   




      **js中所有的类都是函数数据类型的，它通过new 变成一个实例，但是它本事也是一个普通的函数
        js中所有的实例都是对象数据类型的
     */
     function CreateJsPerson(name,age){
      //  var this = {} 
       this.name = name;
       this.age = age;
       this.writeCode =function(){
         console.log(this.name)
       }
      //  return this //这个对象就是当前类的一个实例

     }
     var  p1 = new CreateJsPerson('小明',20)
     var  p2 = new CreateJsPerson('小红',10)
     p1.writeCode()
     p2.writeCode()
     console.log(p1.writeCode === p2.writeCode) //false
    /* 
     p1 和 p2 都是 CreateJsPerson 这个类的实例，所以都拥有writeCode 这个方法，但不同实例之间的方法不同 

     在类中给实例增添的属性（this.xxx=xxx） 属于当前实例的私有属性，实例与实例之间是单独的个体，所以私有属性之间是不相等的  
     */
     var  res = CreateJsPerson('风筝',30) //这是普通函数执行，由于没写return ，所以是undefined ，这个方法中的this 是window
     console.log(res)
  </script>
</body>
</html>