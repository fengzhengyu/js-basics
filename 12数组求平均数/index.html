<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title> 数组求平均数 </title>
</head>
<body>


  <script>
    // function avgFn(){
    //   //1 将类数组转换为数组
    //   var ary = []  ;
    //   for(var i=0;i<arguments.length;i++){
    //     ary[ary.length] = arguments[i]
    //   }
    
    //   // 2 数据排序
    //   ary.sort(function(a,b) {return a-b;})
     
    //   // 3删除首尾
    //   ary.pop();
    //   ary.shift()
    //   console.log((eval(ary.join('+'))/ ary.length).toFixed(2))
    //   return eval(ary.join('+')) / ary.length
    // }
  
   
    // console.log( avgFn(9.8,9.7,10,9.9,9.0,9.8,3.0))
    // 优化上面方法

    // Array.prototype.mySlice = function () {
    //   //this ->当前这个数组ary
    //   // 克隆一模一样的 堆内存不同
      
    //   //内置代码 
    //   var ary = [];
    //   for(var i=0;i<this.length;i++){
    //     ary[ary.length] = this[i];
    //   }
    //   return ary;
    // }
    // var  ary =[12,23,55]
    // var newAry = ary.mySlice();
    // console.log(newAry )


      // 优化后
    // function avgFn(){
    //   //1 将类数组转换为数组 :把arguments 克隆一份一某一样的

    //   // 优化 借用数组原型slice方法，当slice执行的时候，让方法中的this变出我们的arguments,用call
    //   var ary = Array.prototype.slice.call(arguments); //另一种写法 [].slice.call(arguments)

    //   // 2 数据排序
    //   ary.sort(function(a,b) {return a-b;})
     
    //   // 3删除首尾
    //   ary.pop();
    //   ary.shift()
    //   console.log((eval(ary.join('+'))/ ary.length).toFixed(2))
    //   return eval(ary.join('+')) / ary.length
    //}

    // 另一种方法： 借用数组原型的方法
    function avgFn(){
      [].sort.call(arguments,function(a,b){
        return a-b;
      });
      [].shift.call(arguments);
      [].pop.call(arguments);
      return  (eval([].join.call(arguments,"+")) / arguments.length).toFixed(2)
    }
    console.log( avgFn(9.8,9.7,10,9.9,9.0,9.8,3.0))

    //类数组（arguments） 可以通过call方法 借用数组的所有方法 ，不存在任何兼容问题
  </script>


</body>
</html>